// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;

import '../../frb_generated.dart';
import '../../media.dart';
import '../../media/constraints.dart';

part 'api.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `into_ptr`, `into_ptr`, `into_ptr`, `into_ptr`, `into_ptr`, `into_ptr`, `into_ptr`
// These functions are ignored (category: IgnoreBecauseNotAllowedOwner): `from_ptr`

/// Returns the [`Vec<ApiMediaDeviceDetails>`] from the provided
/// [`ForeignClass`] address.
List<ApiMediaDeviceDetails> vecMediaDeviceDetailsFromRaw({required int ptr}) =>
    RustLib.instance.api.crateApiDartApiVecMediaDeviceDetailsFromRaw(ptr: ptr);

/// Returns the [`Vec<ApiMediaDisplayDetails>`] from the provided
/// [`ForeignClass`] address.
List<ApiMediaDisplayDetails> vecMediaDisplayDetailsFromRaw({
  required int ptr,
}) =>
    RustLib.instance.api.crateApiDartApiVecMediaDisplayDetailsFromRaw(ptr: ptr);

/// Logs Dart exception.
void logDartException({required String message, required String stackTrace}) =>
    RustLib.instance.api.crateApiDartApiLogDartException(
      message: message,
      stackTrace: stackTrace,
    );

/// Sets the provided [`Dart_Handle`] as a callback for the Rust panic hook.
void onPanic({required Object cb}) =>
    RustLib.instance.api.crateApiDartApiOnPanic(cb: cb);

/// Sets the provided [`DART_HANDLER_PORT`].
void setDartOpaqueMessagePort({required PlatformInt64 dartHandlerPort}) =>
    RustLib.instance.api.crateApiDartApiSetDartOpaqueMessagePort(
      dartHandlerPort: dartHandlerPort,
    );

abstract class ForeignClass {}

/// Constraints applicable to audio tracks.
class ApiAudioConstraints {
  /// Identifier of the device generating the content for the media track.
  String? deviceId;

  /// Automatically manages changes in the volume of its source media to
  /// maintain a steady overall volume level.
  ConstrainBoolean? autoGainControl;

  /// Indicator whether to enable noise suppression for reducing background
  /// sounds.
  ConstrainBoolean? noiseSuppression;

  /// Level of aggressiveness for noise suppression, if enabled.
  ///
  /// __NOTE__: Only supported on desktop platforms.
  NoiseSuppressionLevel? noiseSuppressionLevel;

  /// Indicator whether to automatically enable echo cancellation for
  /// preventing feedback.
  ConstrainBoolean? echoCancellation;

  /// Indicator whether to enable a high-pass filter for eliminating
  /// low-frequency noise.
  ///
  /// __NOTE__: Only supported on desktop platforms.
  ConstrainBoolean? highPassFilter;

  ApiAudioConstraints({
    this.deviceId,
    this.autoGainControl,
    this.noiseSuppression,
    this.noiseSuppressionLevel,
    this.echoCancellation,
    this.highPassFilter,
  });

  @override
  int get hashCode =>
      deviceId.hashCode ^
      autoGainControl.hashCode ^
      noiseSuppression.hashCode ^
      noiseSuppressionLevel.hashCode ^
      echoCancellation.hashCode ^
      highPassFilter.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiAudioConstraints &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          autoGainControl == other.autoGainControl &&
          noiseSuppression == other.noiseSuppression &&
          noiseSuppressionLevel == other.noiseSuppressionLevel &&
          echoCancellation == other.echoCancellation &&
          highPassFilter == other.highPassFilter;
}

@freezed
sealed class ApiConstrainFacingMode with _$ApiConstrainFacingMode {
  const ApiConstrainFacingMode._();

  /// Exact value required for this property.
  const factory ApiConstrainFacingMode.exact(FacingMode field0) =
      ApiConstrainFacingMode_Exact;

  /// Ideal (target) value for this property.
  const factory ApiConstrainFacingMode.ideal(FacingMode field0) =
      ApiConstrainFacingMode_Ideal;
}

/// Constraints applicable to video tracks that are sourced from some media
/// device.
class ApiDeviceVideoTrackConstraints {
  /// Identifier of the device generating the content for the media track.
  String? deviceId;

  /// Describes the directions that the camera can face, as seen from the
  /// user's perspective.
  ApiConstrainFacingMode? facingMode;

  /// Height of the video in pixels.
  ConstrainU32? height;

  /// Width of the video in pixels.
  ConstrainU32? width;

  ApiDeviceVideoTrackConstraints({
    this.deviceId,
    this.facingMode,
    this.height,
    this.width,
  });

  @override
  int get hashCode =>
      deviceId.hashCode ^
      facingMode.hashCode ^
      height.hashCode ^
      width.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiDeviceVideoTrackConstraints &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          facingMode == other.facingMode &&
          height == other.height &&
          width == other.width;
}

/// Constraints applicable to video tracks sourced from a screen capturing.
class ApiDisplayVideoTrackConstraints {
  /// Identifier of the device generating the content for the media track.
  String? deviceId;

  /// [Height][1] of the video in pixels.
  ///
  /// [1]: https://tinyurl.com/w3-streams#def-constraint-height
  ConstrainU32? height;

  /// [Width][1] of the video in pixels.
  ///
  /// [1]: https://tinyurl.com/w3-streams#def-constraint-width
  ConstrainU32? width;

  /// [Frame rate][1] of the video.
  ///
  /// [1]: https://w3.org/TR/mediacapture-streams#dfn-framerate
  ConstrainU32? frameRate;

  ApiDisplayVideoTrackConstraints({
    this.deviceId,
    this.height,
    this.width,
    this.frameRate,
  });

  @override
  int get hashCode =>
      deviceId.hashCode ^ height.hashCode ^ width.hashCode ^ frameRate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiDisplayVideoTrackConstraints &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          height == other.height &&
          width == other.width &&
          frameRate == other.frameRate;
}

/// Representation of a [MediaDeviceInfo][0] ONLY for input devices.
///
/// [0]: https://w3.org/TR/mediacapture-streams#device-info
class ApiMediaDeviceDetails {
  /// [`MediaDeviceKind`] of this [`ApiMediaDeviceDetails`].
  ///
  /// [`MediaDeviceKind`]: MediaDeviceKind
  final MediaDeviceKind kind;

  /// Unique identifier of the device represented by this
  /// [`ApiMediaDeviceDetails`].
  final String deviceId;

  /// Label describing the device represented by this
  /// [`ApiMediaDeviceDetails`] (for example, "External USB Webcam").
  final String label;

  /// Group identifier of the device represented by this
  /// [`ApiMediaDeviceDetails`].
  ///
  /// Two devices have the same group identifier if they belong to the same
  /// physical device. For example, the audio input and output devices
  /// representing the speaker and microphone of the same headset have the
  /// same [groupId][1].
  ///
  /// [1]: https://w3.org/TR/mediacapture-streams#dom-mediadeviceinfo-groupid
  final String? groupId;

  /// Indicator whether the last attempt to use the provided device failed.
  final bool isFailed;

  const ApiMediaDeviceDetails({
    required this.kind,
    required this.deviceId,
    required this.label,
    this.groupId,
    required this.isFailed,
  });

  @override
  int get hashCode =>
      kind.hashCode ^
      deviceId.hashCode ^
      label.hashCode ^
      groupId.hashCode ^
      isFailed.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiMediaDeviceDetails &&
          runtimeType == other.runtimeType &&
          kind == other.kind &&
          deviceId == other.deviceId &&
          label == other.label &&
          groupId == other.groupId &&
          isFailed == other.isFailed;
}

/// Representation of a display source.
class ApiMediaDisplayDetails {
  /// Unique identifier of the display represented by this
  /// [`ApiMediaDisplayDetails`].
  final String deviceId;

  /// Title describing the represented display.
  final String? title;

  const ApiMediaDisplayDetails({required this.deviceId, this.title});

  @override
  int get hashCode => deviceId.hashCode ^ title.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiMediaDisplayDetails &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          title == other.title;
}

/// [MediaStreamConstraints][1] wrapper.
///
/// [1]: https://w3.org/TR/mediacapture-streams#dom-mediastreamconstraints
class ApiMediaStreamSettings {
  /// [MediaStreamConstraints][1] for the audio media type.
  ///
  /// [1]: https://w3.org/TR/mediacapture-streams#dom-mediastreamconstraints
  ApiAudioConstraints? audio;

  /// [MediaStreamConstraints][1] for the device video media type.
  ///
  /// [1]: https://w3.org/TR/mediacapture-streams#dom-mediastreamconstraints
  ApiDeviceVideoTrackConstraints? deviceVideo;

  /// [MediaStreamConstraints][1] for the display video media type.
  ///
  /// [1]: https://w3.org/TR/mediacapture-streams#dom-mediastreamconstraints
  ApiDisplayVideoTrackConstraints? displayVideo;

  ApiMediaStreamSettings({this.audio, this.deviceVideo, this.displayVideo});

  @override
  int get hashCode =>
      audio.hashCode ^ deviceVideo.hashCode ^ displayVideo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiMediaStreamSettings &&
          runtimeType == other.runtimeType &&
          audio == other.audio &&
          deviceVideo == other.deviceVideo &&
          displayVideo == other.displayVideo;
}
