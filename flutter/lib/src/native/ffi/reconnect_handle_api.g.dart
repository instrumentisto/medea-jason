// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.49.0.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names

import 'dart:convert';
import 'dart:async';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';

import 'package:meta/meta.dart';
import 'package:meta/meta.dart';
import 'dart:ffi' as ffi;

abstract class ReconnectHandleApi {
  /// Tries to reconnect a [`Room`] after the provided delay in milliseconds.
  ///
  /// If the [`Room`] is already reconnecting then new reconnection attempt won't
  /// be performed. Instead, it will wait for the first reconnection attempt
  /// result and use it here..
  ///
  /// [`Room`]: crate::room::Room
  MyDartFuture reconnectHandleReconnectWithDelay(
      {required ReconnectHandle reconnectHandle,
      required int delayMs,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kReconnectHandleReconnectWithDelayConstMeta;

  /// Tries to reconnect a [`Room`] in a loop with a growing backoff delay.
  ///
  /// The first attempt will be performed immediately, and the second attempt will
  /// be performed after `starting_delay_ms`.
  ///
  /// Delay between reconnection attempts won't be greater than
  /// `max_delay_ms`.
  ///
  /// After each reconnection attempt, delay between reconnections will be
  /// multiplied by the given `multiplier` until it reaches `max_delay_ms`.
  ///
  /// If `multiplier` is a negative number then it will be considered as `0.0`.
  /// reconnect_handle might cause a busy loop, so it's not recommended.
  ///
  /// Max elapsed time can be limited with an optional `max_elapsed_time_ms`
  /// argument.
  ///
  /// If the [`Room`] is already reconnecting then new reconnection attempt won't
  /// be performed. Instead, it will wait for the first reconnection attempt
  /// result and use it here.
  ///
  /// [`Room`]: crate::room::Room
  MyDartFuture reconnectHandleReconnectWithBackoff(
      {required ReconnectHandle reconnectHandle,
      required int startingDelay,
      required double multiplier,
      required int maxDelay,
      int? maxElapsedTimeMs,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kReconnectHandleReconnectWithBackoffConstMeta;
}

@sealed
class MyDartFuture extends FrbOpaque {
  MyDartFuture.fromRaw(int ptr, int drop, int share)
      : super.unsafe(ptr, drop, share);
}

@sealed
class ReconnectHandle extends FrbOpaque {
  ReconnectHandle.fromRaw(int ptr, int drop, int share)
      : super.unsafe(ptr, drop, share);
}

class ReconnectHandleApiImpl implements ReconnectHandleApi {
  final ReconnectHandleApiPlatform _platform;
  factory ReconnectHandleApiImpl(ExternalLibrary dylib) =>
      ReconnectHandleApiImpl.raw(ReconnectHandleApiPlatform(dylib));

  /// Only valid on web/WASM platforms.
  factory ReconnectHandleApiImpl.wasm(FutureOr<WasmModule> module) =>
      ReconnectHandleApiImpl(module as ExternalLibrary);
  ReconnectHandleApiImpl.raw(this._platform);
  MyDartFuture reconnectHandleReconnectWithDelay(
      {required ReconnectHandle reconnectHandle,
      required int delayMs,
      dynamic hint}) {
    var arg0 = _platform.api2wire_ReconnectHandle(reconnectHandle);
    var arg1 = _platform.api2wire_i64(delayMs);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner
          .wire_reconnect_handle_reconnect_with_delay(arg0, arg1),
      parseSuccessData: _wire2api_SyncReturn_MyDartFuture,
      constMeta: kReconnectHandleReconnectWithDelayConstMeta,
      argValues: [reconnectHandle, delayMs],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta
      get kReconnectHandleReconnectWithDelayConstMeta =>
          const FlutterRustBridgeTaskConstMeta(
            debugName: "reconnect_handle_reconnect_with_delay",
            argNames: ["reconnectHandle", "delayMs"],
          );

  MyDartFuture reconnectHandleReconnectWithBackoff(
      {required ReconnectHandle reconnectHandle,
      required int startingDelay,
      required double multiplier,
      required int maxDelay,
      int? maxElapsedTimeMs,
      dynamic hint}) {
    var arg0 = _platform.api2wire_ReconnectHandle(reconnectHandle);
    var arg1 = _platform.api2wire_i64(startingDelay);
    var arg2 = api2wire_f64(multiplier);
    var arg3 = api2wire_u32(maxDelay);
    var arg4 = _platform.api2wire_opt_box_autoadd_u32(maxElapsedTimeMs);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner
          .wire_reconnect_handle_reconnect_with_backoff(
              arg0, arg1, arg2, arg3, arg4),
      parseSuccessData: _wire2api_SyncReturn_MyDartFuture,
      constMeta: kReconnectHandleReconnectWithBackoffConstMeta,
      argValues: [
        reconnectHandle,
        startingDelay,
        multiplier,
        maxDelay,
        maxElapsedTimeMs
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta
      get kReconnectHandleReconnectWithBackoffConstMeta =>
          const FlutterRustBridgeTaskConstMeta(
            debugName: "reconnect_handle_reconnect_with_backoff",
            argNames: [
              "reconnectHandle",
              "startingDelay",
              "multiplier",
              "maxDelay",
              "maxElapsedTimeMs"
            ],
          );

// Section: wire2api

  MyDartFuture _wire2api_MyDartFuture(dynamic raw) {
    return MyDartFuture.fromRaw(raw[0], raw[1], raw[2]);
  }

  MyDartFuture _wire2api_SyncReturn_MyDartFuture(dynamic raw) {
    var pointBitLen = raw.length ~/ 3;
    var ptrList = List.filled(pointBitLen, 0);
    var dropList = List.filled(pointBitLen, 0);
    var lendList = List.filled(pointBitLen, 0);

    List.copyRange(ptrList, 0, raw, 0, pointBitLen);
    List.copyRange(dropList, 0, raw, pointBitLen, pointBitLen * 2);
    List.copyRange(lendList, 0, raw, pointBitLen * 2);

    int ptr = 0;
    int drop = 0;
    int lend = 0;

    if (pointBitLen == 8) {
      ptr = ByteData.view(Uint8List.fromList(ptrList).buffer).getUint64(0);
      drop = ByteData.view(Uint8List.fromList(dropList).buffer).getUint64(0);
      lend = ByteData.view(Uint8List.fromList(lendList).buffer).getUint64(0);
    } else if (pointBitLen == 4) {
      ptr = ByteData.view(Uint8List.fromList(ptrList).buffer).getUint32(0);
      drop = ByteData.view(Uint8List.fromList(dropList).buffer).getUint32(0);
      lend = ByteData.view(Uint8List.fromList(lendList).buffer).getUint32(0);
    }

    return MyDartFuture.fromRaw(ptr, drop, lend);
  }
}

// Section: api2wire

@protected
double api2wire_f64(double raw) {
  return raw;
}

@protected
int api2wire_u32(int raw) {
  return raw;
}

class ReconnectHandleApiPlatform
    extends FlutterRustBridgeBase<ReconnectHandleApiWire> {
  ReconnectHandleApiPlatform(ffi.DynamicLibrary dylib)
      : super(ReconnectHandleApiWire(dylib));
// Section: api2wire

  @protected
  ffi.Pointer<wire_ReconnectHandle> api2wire_ReconnectHandle(
      ReconnectHandle raw) {
    if (raw.isStale()) {
      throw 'Use after dispose.';
    }
    final ptr = inner.new_ReconnectHandle();
    _api_fill_to_wire_ReconnectHandle(raw, ptr);
    return ptr;
  }

  @protected
  ffi.Pointer<ffi.Uint32> api2wire_box_autoadd_u32(int raw) {
    return inner.new_box_autoadd_u32_10(api2wire_u32(raw));
  }

  @protected
  int api2wire_i64(int raw) {
    return raw;
  }

  @protected
  ffi.Pointer<ffi.Uint32> api2wire_opt_box_autoadd_u32(int? raw) {
    return raw == null ? ffi.nullptr : api2wire_box_autoadd_u32(raw);
  }

// Section: api_fill_to_wire

  void _api_fill_to_wire_ReconnectHandle(
      ReconnectHandle apiObj, ffi.Pointer<wire_ReconnectHandle> wireObj) {
    wireObj.ref.ptr = FrbOpaque.share(apiObj).cast();
  }
}

// ignore_for_file: camel_case_types, non_constant_identifier_names, avoid_positional_boolean_parameters, annotate_overrides, constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.

/// generated by flutter_rust_bridge
class ReconnectHandleApiWire implements FlutterRustBridgeWireBase {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  ReconnectHandleApiWire(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  ReconnectHandleApiWire.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  void free_WireSyncReturnStruct(
    WireSyncReturnStruct val,
  ) {
    return _free_WireSyncReturnStruct(
      val,
    );
  }

  late final _free_WireSyncReturnStructPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(WireSyncReturnStruct)>>(
          'free_WireSyncReturnStruct');
  late final _free_WireSyncReturnStruct = _free_WireSyncReturnStructPtr
      .asFunction<void Function(WireSyncReturnStruct)>();

  void store_dart_post_cobject(
    DartPostCObjectFnType ptr,
  ) {
    return _store_dart_post_cobject(
      ptr,
    );
  }

  late final _store_dart_post_cobjectPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(DartPostCObjectFnType)>>(
          'store_dart_post_cobject');
  late final _store_dart_post_cobject = _store_dart_post_cobjectPtr
      .asFunction<void Function(DartPostCObjectFnType)>();

  WireSyncReturnStruct wire_reconnect_handle_reconnect_with_delay(
    ffi.Pointer<wire_ReconnectHandle> reconnect_handle,
    int delay_ms,
  ) {
    return _wire_reconnect_handle_reconnect_with_delay(
      reconnect_handle,
      delay_ms,
    );
  }

  late final _wire_reconnect_handle_reconnect_with_delayPtr = _lookup<
      ffi.NativeFunction<
          WireSyncReturnStruct Function(ffi.Pointer<wire_ReconnectHandle>,
              ffi.Int64)>>('wire_reconnect_handle_reconnect_with_delay');
  late final _wire_reconnect_handle_reconnect_with_delay =
      _wire_reconnect_handle_reconnect_with_delayPtr.asFunction<
          WireSyncReturnStruct Function(
              ffi.Pointer<wire_ReconnectHandle>, int)>();

  WireSyncReturnStruct wire_reconnect_handle_reconnect_with_backoff(
    ffi.Pointer<wire_ReconnectHandle> reconnect_handle,
    int starting_delay,
    double multiplier,
    int max_delay,
    ffi.Pointer<ffi.Uint32> max_elapsed_time_ms,
  ) {
    return _wire_reconnect_handle_reconnect_with_backoff(
      reconnect_handle,
      starting_delay,
      multiplier,
      max_delay,
      max_elapsed_time_ms,
    );
  }

  late final _wire_reconnect_handle_reconnect_with_backoffPtr = _lookup<
          ffi.NativeFunction<
              WireSyncReturnStruct Function(ffi.Pointer<wire_ReconnectHandle>,
                  ffi.Int64, ffi.Double, ffi.Uint32, ffi.Pointer<ffi.Uint32>)>>(
      'wire_reconnect_handle_reconnect_with_backoff');
  late final _wire_reconnect_handle_reconnect_with_backoff =
      _wire_reconnect_handle_reconnect_with_backoffPtr.asFunction<
          WireSyncReturnStruct Function(ffi.Pointer<wire_ReconnectHandle>, int,
              double, int, ffi.Pointer<ffi.Uint32>)>();

  ffi.Pointer<wire_ReconnectHandle> new_ReconnectHandle() {
    return _new_ReconnectHandle();
  }

  late final _new_ReconnectHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wire_ReconnectHandle> Function()>>(
          'new_ReconnectHandle');
  late final _new_ReconnectHandle = _new_ReconnectHandlePtr
      .asFunction<ffi.Pointer<wire_ReconnectHandle> Function()>();

  ffi.Pointer<ffi.Uint32> new_box_autoadd_u32_10(
    int value,
  ) {
    return _new_box_autoadd_u32_10(
      value,
    );
  }

  late final _new_box_autoadd_u32_10Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Uint32> Function(ffi.Uint32)>>(
          'new_box_autoadd_u32_10');
  late final _new_box_autoadd_u32_10 = _new_box_autoadd_u32_10Ptr
      .asFunction<ffi.Pointer<ffi.Uint32> Function(int)>();

  void drop_box_autoadd_u32_10(
    ffi.Pointer<ffi.Uint32> raw,
  ) {
    return _drop_box_autoadd_u32_10(
      raw,
    );
  }

  late final _drop_box_autoadd_u32_10Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Uint32>)>>(
          'drop_box_autoadd_u32_10');
  late final _drop_box_autoadd_u32_10 = _drop_box_autoadd_u32_10Ptr
      .asFunction<void Function(ffi.Pointer<ffi.Uint32>)>();
}

class wire_ReconnectHandle extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef DartPostCObjectFnType = ffi.Pointer<
    ffi.NativeFunction<ffi.Bool Function(DartPort, ffi.Pointer<ffi.Void>)>>;
typedef DartPort = ffi.Int64;
