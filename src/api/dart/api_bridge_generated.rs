#![allow(
    non_camel_case_types,
    unused,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::double_parens,
    non_snake_case,
    clippy::too_many_arguments
)]
// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.82.4.

use crate::api::dart::api::*;
use core::panic::UnwindSafe;
use flutter_rust_bridge::{rust2dart::IntoIntoDart, *};
use std::{ffi::c_void, sync::Arc};

// Section: imports

use crate::{
    media::{
        constraints::{ConstrainBoolean, ConstrainU32, FacingMode},
        track::{remote::MediaDirection, MediaSourceKind},
        MediaDeviceKind, MediaKind,
    },
    room::RoomCloseReason,
};

// Section: wire functions

fn wire_connection_handle_from_ptr_impl(
    ptr: impl Wire2Api<usize> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "connection_handle_from_ptr",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.wire2api();
            Result::<_, ()>::Ok(connection_handle_from_ptr(api_ptr))
        },
    )
}
fn wire_connection_handle_on_close_impl(
    connection: impl Wire2Api<RustOpaque<ConnectionHandle>> + UnwindSafe,
    f: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "connection_handle_on_close",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_connection = connection.wire2api();
            let api_f = f.wire2api();
            connection_handle_on_close(api_connection, api_f)
        },
    )
}
fn wire_connection_handle_on_remote_track_added_impl(
    connection: impl Wire2Api<RustOpaque<ConnectionHandle>> + UnwindSafe,
    f: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "connection_handle_on_remote_track_added",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_connection = connection.wire2api();
            let api_f = f.wire2api();
            connection_handle_on_remote_track_added(api_connection, api_f)
        },
    )
}
fn wire_connection_handle_on_quality_score_update_impl(
    connection: impl Wire2Api<RustOpaque<ConnectionHandle>> + UnwindSafe,
    f: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "connection_handle_on_quality_score_update",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_connection = connection.wire2api();
            let api_f = f.wire2api();
            connection_handle_on_quality_score_update(api_connection, api_f)
        },
    )
}
fn wire_connection_handle_get_remote_member_id_impl(
    connection: impl Wire2Api<RustOpaque<ConnectionHandle>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "connection_handle_get_remote_member_id",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_connection = connection.wire2api();
            connection_handle_get_remote_member_id(api_connection)
        },
    )
}
fn wire_connection_handle_enable_remote_audio_impl(
    connection: impl Wire2Api<RustOpaque<ConnectionHandle>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "connection_handle_enable_remote_audio",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_connection = connection.wire2api();
            Result::<_, ()>::Ok(connection_handle_enable_remote_audio(
                api_connection,
            ))
        },
    )
}
fn wire_connection_handle_disable_remote_audio_impl(
    connection: impl Wire2Api<RustOpaque<ConnectionHandle>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "connection_handle_disable_remote_audio",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_connection = connection.wire2api();
            Result::<_, ()>::Ok(connection_handle_disable_remote_audio(
                api_connection,
            ))
        },
    )
}
fn wire_connection_handle_enable_remote_video_impl(
    connection: impl Wire2Api<RustOpaque<ConnectionHandle>> + UnwindSafe,
    source_kind: impl Wire2Api<Option<MediaSourceKind>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "connection_handle_enable_remote_video",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_connection = connection.wire2api();
            let api_source_kind = source_kind.wire2api();
            Result::<_, ()>::Ok(connection_handle_enable_remote_video(
                api_connection,
                api_source_kind,
            ))
        },
    )
}
fn wire_connection_handle_disable_remote_video_impl(
    connection: impl Wire2Api<RustOpaque<ConnectionHandle>> + UnwindSafe,
    source_kind: impl Wire2Api<Option<MediaSourceKind>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "connection_handle_disable_remote_video",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_connection = connection.wire2api();
            let api_source_kind = source_kind.wire2api();
            Result::<_, ()>::Ok(connection_handle_disable_remote_video(
                api_connection,
                api_source_kind,
            ))
        },
    )
}
fn wire_on_panic_impl(
    cb: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "on_panic",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_cb = cb.wire2api();
            Result::<_, ()>::Ok(on_panic(api_cb))
        },
    )
}
fn wire_jason_new_impl() -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "jason_new",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || Result::<_, ()>::Ok(jason_new()),
    )
}
fn wire_jason_init_room_impl(
    jason: impl Wire2Api<RustOpaque<Jason>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "jason_init_room",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_jason = jason.wire2api();
            Result::<_, ()>::Ok(jason_init_room(api_jason))
        },
    )
}
fn wire_jason_media_manager_impl(
    jason: impl Wire2Api<RustOpaque<Jason>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "jason_media_manager",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_jason = jason.wire2api();
            Result::<_, ()>::Ok(jason_media_manager(api_jason))
        },
    )
}
fn wire_jason_close_room_impl(
    jason: impl Wire2Api<RustOpaque<Jason>> + UnwindSafe,
    room_to_delete: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "jason_close_room",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_jason = jason.wire2api();
            let api_room_to_delete = room_to_delete.wire2api();
            Result::<_, ()>::Ok(jason_close_room(api_jason, api_room_to_delete))
        },
    )
}
fn wire_jason_dispose_impl(
    jason: impl Wire2Api<RustOpaque<Jason>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "jason_dispose",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_jason = jason.wire2api();
            Result::<_, ()>::Ok(jason_dispose(api_jason))
        },
    )
}
fn wire_local_media_track_from_ptr_impl(
    ptr: impl Wire2Api<usize> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "local_media_track_from_ptr",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.wire2api();
            Result::<_, ()>::Ok(local_media_track_from_ptr(api_ptr))
        },
    )
}
fn wire_vec_local_tracks_from_ptr_impl(
    ptr: impl Wire2Api<usize> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "vec_local_tracks_from_ptr",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.wire2api();
            Result::<_, ()>::Ok(vec_local_tracks_from_ptr(api_ptr))
        },
    )
}
fn wire_local_media_track_get_track_impl(
    track: impl Wire2Api<RustOpaque<LocalMediaTrack>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "local_media_track_get_track",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            Result::<_, ()>::Ok(local_media_track_get_track(api_track))
        },
    )
}
fn wire_local_media_track_kind_impl(
    track: impl Wire2Api<RustOpaque<LocalMediaTrack>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "local_media_track_kind",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            Result::<_, ()>::Ok(local_media_track_kind(api_track))
        },
    )
}
fn wire_local_media_track_on_ended_impl(
    track: impl Wire2Api<RustOpaque<LocalMediaTrack>> + UnwindSafe,
    f: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "local_media_track_on_ended",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            let api_f = f.wire2api();
            Result::<_, ()>::Ok(local_media_track_on_ended(api_track, api_f))
        },
    )
}
fn wire_local_media_track_state_impl(
    track: impl Wire2Api<RustOpaque<LocalMediaTrack>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "local_media_track_state",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            Result::<_, ()>::Ok(local_media_track_state(api_track))
        },
    )
}
fn wire_local_media_track_media_source_kind_impl(
    track: impl Wire2Api<RustOpaque<LocalMediaTrack>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "local_media_track_media_source_kind",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            Result::<_, ()>::Ok(local_media_track_media_source_kind(api_track))
        },
    )
}
fn wire_local_media_track_free_impl(
    track: impl Wire2Api<RustOpaque<LocalMediaTrack>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "local_media_track_free",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            Result::<_, ()>::Ok(local_media_track_free(api_track))
        },
    )
}
fn wire_vec_media_device_details_from_ptr_impl(
    ptr: impl Wire2Api<usize> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "vec_media_device_details_from_ptr",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.wire2api();
            Result::<_, ()>::Ok(vec_media_device_details_from_ptr(api_ptr))
        },
    )
}
fn wire_vec_media_display_details_from_ptr_impl(
    ptr: impl Wire2Api<usize> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "vec_media_display_details_from_ptr",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.wire2api();
            Result::<_, ()>::Ok(vec_media_display_details_from_ptr(api_ptr))
        },
    )
}
fn wire_media_manager_handle_init_local_tracks_impl(
    manager: impl Wire2Api<RustOpaque<MediaManagerHandle>> + UnwindSafe,
    caps: impl Wire2Api<ApiMediaStreamSettings> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "media_manager_handle_init_local_tracks",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_manager = manager.wire2api();
            let api_caps = caps.wire2api();
            Result::<_, ()>::Ok(media_manager_handle_init_local_tracks(
                api_manager,
                api_caps,
            ))
        },
    )
}
fn wire_media_manager_handle_enumerate_devices_impl(
    manager: impl Wire2Api<RustOpaque<MediaManagerHandle>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "media_manager_handle_enumerate_devices",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_manager = manager.wire2api();
            Result::<_, ()>::Ok(media_manager_handle_enumerate_devices(
                api_manager,
            ))
        },
    )
}
fn wire_media_manager_handle_enumerate_displays_impl(
    manager: impl Wire2Api<RustOpaque<MediaManagerHandle>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "media_manager_handle_enumerate_displays",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_manager = manager.wire2api();
            Result::<_, ()>::Ok(media_manager_handle_enumerate_displays(
                api_manager,
            ))
        },
    )
}
fn wire_media_manager_handle_set_output_audio_id_impl(
    manager: impl Wire2Api<RustOpaque<MediaManagerHandle>> + UnwindSafe,
    device_id: impl Wire2Api<String> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "media_manager_handle_set_output_audio_id",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_manager = manager.wire2api();
            let api_device_id = device_id.wire2api();
            Result::<_, ()>::Ok(media_manager_handle_set_output_audio_id(
                api_manager,
                api_device_id,
            ))
        },
    )
}
fn wire_media_manager_handle_set_microphone_volume_impl(
    manager: impl Wire2Api<RustOpaque<MediaManagerHandle>> + UnwindSafe,
    level: impl Wire2Api<i64> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "media_manager_handle_set_microphone_volume",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_manager = manager.wire2api();
            let api_level = level.wire2api();
            Result::<_, ()>::Ok(media_manager_handle_set_microphone_volume(
                api_manager,
                api_level,
            ))
        },
    )
}
fn wire_media_manager_handle_microphone_volume_is_available_impl(
    manager: impl Wire2Api<RustOpaque<MediaManagerHandle>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "media_manager_handle_microphone_volume_is_available",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_manager = manager.wire2api();
            Result::<_, ()>::Ok(
                media_manager_handle_microphone_volume_is_available(
                    api_manager,
                ),
            )
        },
    )
}
fn wire_media_manager_handle_microphone_volume_impl(
    manager: impl Wire2Api<RustOpaque<MediaManagerHandle>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "media_manager_handle_microphone_volume",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_manager = manager.wire2api();
            Result::<_, ()>::Ok(media_manager_handle_microphone_volume(
                api_manager,
            ))
        },
    )
}
fn wire_media_manager_handle_on_device_change_impl(
    manager: impl Wire2Api<RustOpaque<MediaManagerHandle>> + UnwindSafe,
    cb: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "media_manager_handle_on_device_change",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_manager = manager.wire2api();
            let api_cb = cb.wire2api();
            media_manager_handle_on_device_change(api_manager, api_cb)
        },
    )
}
fn wire_reconnect_handle_from_ptr_impl(
    ptr: impl Wire2Api<usize> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "reconnect_handle_from_ptr",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.wire2api();
            Result::<_, ()>::Ok(reconnect_handle_from_ptr(api_ptr))
        },
    )
}
fn wire_reconnect_handle_reconnect_with_delay_impl(
    reconnect_handle: impl Wire2Api<RustOpaque<ReconnectHandle>> + UnwindSafe,
    delay_ms: impl Wire2Api<u32> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "reconnect_handle_reconnect_with_delay",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_reconnect_handle = reconnect_handle.wire2api();
            let api_delay_ms = delay_ms.wire2api();
            Result::<_, ()>::Ok(reconnect_handle_reconnect_with_delay(
                api_reconnect_handle,
                api_delay_ms,
            ))
        },
    )
}
fn wire_reconnect_handle_reconnect_with_backoff_impl(
    reconnect_handle: impl Wire2Api<RustOpaque<ReconnectHandle>> + UnwindSafe,
    starting_delay: impl Wire2Api<u32> + UnwindSafe,
    multiplier: impl Wire2Api<f64> + UnwindSafe,
    max_delay: impl Wire2Api<u32> + UnwindSafe,
    max_elapsed_time_ms: impl Wire2Api<Option<u32>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "reconnect_handle_reconnect_with_backoff",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_reconnect_handle = reconnect_handle.wire2api();
            let api_starting_delay = starting_delay.wire2api();
            let api_multiplier = multiplier.wire2api();
            let api_max_delay = max_delay.wire2api();
            let api_max_elapsed_time_ms = max_elapsed_time_ms.wire2api();
            Result::<_, ()>::Ok(reconnect_handle_reconnect_with_backoff(
                api_reconnect_handle,
                api_starting_delay,
                api_multiplier,
                api_max_delay,
                api_max_elapsed_time_ms,
            ))
        },
    )
}
fn wire_remote_media_track_from_ptr_impl(
    ptr: impl Wire2Api<usize> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "remote_media_track_from_ptr",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.wire2api();
            Result::<_, ()>::Ok(remote_media_track_from_ptr(api_ptr))
        },
    )
}
fn wire_remote_media_track_get_track_impl(
    track: impl Wire2Api<RustOpaque<RemoteMediaTrack>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "remote_media_track_get_track",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            Result::<_, ()>::Ok(remote_media_track_get_track(api_track))
        },
    )
}
fn wire_remote_media_track_on_muted_impl(
    track: impl Wire2Api<RustOpaque<RemoteMediaTrack>> + UnwindSafe,
    f: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "remote_media_track_on_muted",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            let api_f = f.wire2api();
            Result::<_, ()>::Ok(remote_media_track_on_muted(api_track, api_f))
        },
    )
}
fn wire_remote_media_track_on_unmuted_impl(
    track: impl Wire2Api<RustOpaque<RemoteMediaTrack>> + UnwindSafe,
    f: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "remote_media_track_on_unmuted",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            let api_f = f.wire2api();
            Result::<_, ()>::Ok(remote_media_track_on_unmuted(api_track, api_f))
        },
    )
}
fn wire_remote_media_track_on_stopped_impl(
    track: impl Wire2Api<RustOpaque<RemoteMediaTrack>> + UnwindSafe,
    f: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "remote_media_track_on_stopped",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            let api_f = f.wire2api();
            Result::<_, ()>::Ok(remote_media_track_on_stopped(api_track, api_f))
        },
    )
}
fn wire_remote_media_track_on_media_direction_changed_impl(
    track: impl Wire2Api<RustOpaque<RemoteMediaTrack>> + UnwindSafe,
    f: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "remote_media_track_on_media_direction_changed",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            let api_f = f.wire2api();
            Result::<_, ()>::Ok(remote_media_track_on_media_direction_changed(
                api_track, api_f,
            ))
        },
    )
}
fn wire_remote_media_track_muted_impl(
    track: impl Wire2Api<RustOpaque<RemoteMediaTrack>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "remote_media_track_muted",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            Result::<_, ()>::Ok(remote_media_track_muted(api_track))
        },
    )
}
fn wire_remote_media_track_kind_impl(
    track: impl Wire2Api<RustOpaque<RemoteMediaTrack>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "remote_media_track_kind",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            Result::<_, ()>::Ok(remote_media_track_kind(api_track))
        },
    )
}
fn wire_remote_media_track_media_source_kind_impl(
    track: impl Wire2Api<RustOpaque<RemoteMediaTrack>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "remote_media_track_media_source_kind",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            Result::<_, ()>::Ok(remote_media_track_media_source_kind(api_track))
        },
    )
}
fn wire_remote_media_track_media_direction_impl(
    track: impl Wire2Api<RustOpaque<RemoteMediaTrack>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "remote_media_track_media_direction",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_track = track.wire2api();
            Result::<_, ()>::Ok(remote_media_track_media_direction(api_track))
        },
    )
}
fn wire_room_close_reason_from_ptr_impl(
    ptr: impl Wire2Api<usize> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_close_reason_from_ptr",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.wire2api();
            Result::<_, ()>::Ok(room_close_reason_from_ptr(api_ptr))
        },
    )
}
fn wire_room_handle_join_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
    token: impl Wire2Api<String> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_join",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            let api_token = token.wire2api();
            Result::<_, ()>::Ok(room_handle_join(api_room_handle, api_token))
        },
    )
}
fn wire_room_handle_set_local_media_settings_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
    settings: impl Wire2Api<ApiMediaStreamSettings> + UnwindSafe,
    stop_first: impl Wire2Api<bool> + UnwindSafe,
    rollback_on_fail: impl Wire2Api<bool> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_set_local_media_settings",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            let api_settings = settings.wire2api();
            let api_stop_first = stop_first.wire2api();
            let api_rollback_on_fail = rollback_on_fail.wire2api();
            Result::<_, ()>::Ok(room_handle_set_local_media_settings(
                api_room_handle,
                api_settings,
                api_stop_first,
                api_rollback_on_fail,
            ))
        },
    )
}
fn wire_room_handle_mute_audio_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_mute_audio",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            Result::<_, ()>::Ok(room_handle_mute_audio(api_room_handle))
        },
    )
}
fn wire_room_handle_unmute_audio_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_unmute_audio",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            Result::<_, ()>::Ok(room_handle_unmute_audio(api_room_handle))
        },
    )
}
fn wire_room_handle_enable_audio_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_enable_audio",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            Result::<_, ()>::Ok(room_handle_enable_audio(api_room_handle))
        },
    )
}
fn wire_room_handle_disable_audio_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_disable_audio",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            Result::<_, ()>::Ok(room_handle_disable_audio(api_room_handle))
        },
    )
}
fn wire_room_handle_mute_video_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
    source_kind: impl Wire2Api<Option<MediaSourceKind>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_mute_video",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            let api_source_kind = source_kind.wire2api();
            Result::<_, ()>::Ok(room_handle_mute_video(
                api_room_handle,
                api_source_kind,
            ))
        },
    )
}
fn wire_room_handle_unmute_video_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
    source_kind: impl Wire2Api<Option<MediaSourceKind>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_unmute_video",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            let api_source_kind = source_kind.wire2api();
            Result::<_, ()>::Ok(room_handle_unmute_video(
                api_room_handle,
                api_source_kind,
            ))
        },
    )
}
fn wire_room_handle_enable_video_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
    source_kind: impl Wire2Api<Option<MediaSourceKind>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_enable_video",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            let api_source_kind = source_kind.wire2api();
            Result::<_, ()>::Ok(room_handle_enable_video(
                api_room_handle,
                api_source_kind,
            ))
        },
    )
}
fn wire_room_handle_disable_video_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
    source_kind: impl Wire2Api<Option<MediaSourceKind>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_disable_video",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            let api_source_kind = source_kind.wire2api();
            Result::<_, ()>::Ok(room_handle_disable_video(
                api_room_handle,
                api_source_kind,
            ))
        },
    )
}
fn wire_room_handle_enable_remote_audio_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_enable_remote_audio",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            Result::<_, ()>::Ok(room_handle_enable_remote_audio(
                api_room_handle,
            ))
        },
    )
}
fn wire_room_handle_disable_remote_audio_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_disable_remote_audio",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            Result::<_, ()>::Ok(room_handle_disable_remote_audio(
                api_room_handle,
            ))
        },
    )
}
fn wire_room_handle_enable_remote_video_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
    source_kind: impl Wire2Api<Option<MediaSourceKind>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_enable_remote_video",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            let api_source_kind = source_kind.wire2api();
            Result::<_, ()>::Ok(room_handle_enable_remote_video(
                api_room_handle,
                api_source_kind,
            ))
        },
    )
}
fn wire_room_handle_disable_remote_video_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
    source_kind: impl Wire2Api<Option<MediaSourceKind>> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_disable_remote_video",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            let api_source_kind = source_kind.wire2api();
            Result::<_, ()>::Ok(room_handle_disable_remote_video(
                api_room_handle,
                api_source_kind,
            ))
        },
    )
}
fn wire_room_handle_on_new_connection_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
    cb: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_on_new_connection",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            let api_cb = cb.wire2api();
            room_handle_on_new_connection(api_room_handle, api_cb)
        },
    )
}
fn wire_room_handle_on_close_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
    cb: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_on_close",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            let api_cb = cb.wire2api();
            room_handle_on_close(api_room_handle, api_cb)
        },
    )
}
fn wire_room_handle_on_local_track_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
    cb: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_on_local_track",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            let api_cb = cb.wire2api();
            room_handle_on_local_track(api_room_handle, api_cb)
        },
    )
}
fn wire_room_handle_on_connection_loss_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
    cb: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_on_connection_loss",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            let api_cb = cb.wire2api();
            room_handle_on_connection_loss(api_room_handle, api_cb)
        },
    )
}
fn wire_room_handle_on_failed_local_media_impl(
    room_handle: impl Wire2Api<RustOpaque<RoomHandle>> + UnwindSafe,
    cb: impl Wire2Api<DartOpaque> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "room_handle_on_failed_local_media",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_room_handle = room_handle.wire2api();
            let api_cb = cb.wire2api();
            room_handle_on_failed_local_media(api_room_handle, api_cb)
        },
    )
}
fn wire_log_dart_exception_impl(
    message: impl Wire2Api<String> + UnwindSafe,
    stack_trace: impl Wire2Api<String> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "log_dart_exception",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_message = message.wire2api();
            let api_stack_trace = stack_trace.wire2api();
            Result::<_, ()>::Ok(log_dart_exception(
                api_message,
                api_stack_trace,
            ))
        },
    )
}
// Section: wrapper structs

// Section: static checks

// Section: allocate functions

// Section: related functions

// Section: impl Wire2Api

pub trait Wire2Api<T> {
    fn wire2api(self) -> T;
}

impl<T, S> Wire2Api<Option<T>> for *mut S
where
    *mut S: Wire2Api<T>,
{
    fn wire2api(self) -> Option<T> {
        (!self.is_null()).then(|| self.wire2api())
    }
}

impl Wire2Api<bool> for bool {
    fn wire2api(self) -> bool {
        self
    }
}

impl Wire2Api<f64> for f64 {
    fn wire2api(self) -> f64 {
        self
    }
}
impl Wire2Api<FacingMode> for i32 {
    fn wire2api(self) -> FacingMode {
        match self {
            0 => FacingMode::User,
            1 => FacingMode::Environment,
            2 => FacingMode::Left,
            3 => FacingMode::Right,
            _ => unreachable!("Invalid variant for FacingMode: {}", self),
        }
    }
}
impl Wire2Api<i32> for i32 {
    fn wire2api(self) -> i32 {
        self
    }
}
impl Wire2Api<i64> for i64 {
    fn wire2api(self) -> i64 {
        self
    }
}
impl Wire2Api<MediaSourceKind> for i32 {
    fn wire2api(self) -> MediaSourceKind {
        match self {
            0 => MediaSourceKind::Device,
            1 => MediaSourceKind::Display,
            _ => unreachable!("Invalid variant for MediaSourceKind: {}", self),
        }
    }
}

impl Wire2Api<u32> for u32 {
    fn wire2api(self) -> u32 {
        self
    }
}
impl Wire2Api<u8> for u8 {
    fn wire2api(self) -> u8 {
        self
    }
}

impl Wire2Api<usize> for usize {
    fn wire2api(self) -> usize {
        self
    }
}
// Section: impl IntoDart

impl support::IntoDart for ApiMediaDeviceDetails {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.kind.into_into_dart().into_dart(),
            self.device_id.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
            self.group_id.into_dart(),
            self.is_failed.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for ApiMediaDeviceDetails {}
impl rust2dart::IntoIntoDart<ApiMediaDeviceDetails> for ApiMediaDeviceDetails {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for ApiMediaDisplayDetails {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.device_id.into_into_dart().into_dart(),
            self.title.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for ApiMediaDisplayDetails {}
impl rust2dart::IntoIntoDart<ApiMediaDisplayDetails>
    for ApiMediaDisplayDetails
{
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for MediaDeviceKind {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::AudioInput => 0,
            Self::VideoInput => 1,
            Self::AudioOutput => 2,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for MediaDeviceKind {}
impl rust2dart::IntoIntoDart<MediaDeviceKind> for MediaDeviceKind {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for MediaDirection {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::SendRecv => 0,
            Self::SendOnly => 1,
            Self::RecvOnly => 2,
            Self::Inactive => 3,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for MediaDirection {}
impl rust2dart::IntoIntoDart<MediaDirection> for MediaDirection {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for MediaKind {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Audio => 0,
            Self::Video => 1,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for MediaKind {}
impl rust2dart::IntoIntoDart<MediaKind> for MediaKind {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for MediaSourceKind {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Device => 0,
            Self::Display => 1,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for MediaSourceKind {}
impl rust2dart::IntoIntoDart<MediaSourceKind> for MediaSourceKind {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for RoomCloseReason {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.is_closed_by_server.into_into_dart().into_dart(),
            self.reason.into_into_dart().into_dart(),
            self.is_err.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for RoomCloseReason {}
impl rust2dart::IntoIntoDart<RoomCloseReason> for RoomCloseReason {
    fn into_into_dart(self) -> Self {
        self
    }
}

// Section: executor

support::lazy_static! {
    pub static ref FLUTTER_RUST_BRIDGE_HANDLER: support::DefaultHandler =
        Default::default();
}

#[cfg(not(target_family = "wasm"))]
mod io {
    use super::*;
    // Section: wire functions

    #[no_mangle]
    pub extern "C" fn wire_connection_handle_from_ptr(
        ptr: usize,
    ) -> support::WireSyncReturn {
        wire_connection_handle_from_ptr_impl(ptr)
    }

    #[no_mangle]
    pub extern "C" fn wire_connection_handle_on_close(
        connection: wire_ConnectionHandle,
        f: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_connection_handle_on_close_impl(connection, f)
    }

    #[no_mangle]
    pub extern "C" fn wire_connection_handle_on_remote_track_added(
        connection: wire_ConnectionHandle,
        f: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_connection_handle_on_remote_track_added_impl(connection, f)
    }

    #[no_mangle]
    pub extern "C" fn wire_connection_handle_on_quality_score_update(
        connection: wire_ConnectionHandle,
        f: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_connection_handle_on_quality_score_update_impl(connection, f)
    }

    #[no_mangle]
    pub extern "C" fn wire_connection_handle_get_remote_member_id(
        connection: wire_ConnectionHandle,
    ) -> support::WireSyncReturn {
        wire_connection_handle_get_remote_member_id_impl(connection)
    }

    #[no_mangle]
    pub extern "C" fn wire_connection_handle_enable_remote_audio(
        connection: wire_ConnectionHandle,
    ) -> support::WireSyncReturn {
        wire_connection_handle_enable_remote_audio_impl(connection)
    }

    #[no_mangle]
    pub extern "C" fn wire_connection_handle_disable_remote_audio(
        connection: wire_ConnectionHandle,
    ) -> support::WireSyncReturn {
        wire_connection_handle_disable_remote_audio_impl(connection)
    }

    #[no_mangle]
    pub extern "C" fn wire_connection_handle_enable_remote_video(
        connection: wire_ConnectionHandle,
        source_kind: *mut i32,
    ) -> support::WireSyncReturn {
        wire_connection_handle_enable_remote_video_impl(connection, source_kind)
    }

    #[no_mangle]
    pub extern "C" fn wire_connection_handle_disable_remote_video(
        connection: wire_ConnectionHandle,
        source_kind: *mut i32,
    ) -> support::WireSyncReturn {
        wire_connection_handle_disable_remote_video_impl(
            connection,
            source_kind,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_on_panic(
        cb: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_on_panic_impl(cb)
    }

    #[no_mangle]
    pub extern "C" fn wire_jason_new() -> support::WireSyncReturn {
        wire_jason_new_impl()
    }

    #[no_mangle]
    pub extern "C" fn wire_jason_init_room(
        jason: wire_Jason,
    ) -> support::WireSyncReturn {
        wire_jason_init_room_impl(jason)
    }

    #[no_mangle]
    pub extern "C" fn wire_jason_media_manager(
        jason: wire_Jason,
    ) -> support::WireSyncReturn {
        wire_jason_media_manager_impl(jason)
    }

    #[no_mangle]
    pub extern "C" fn wire_jason_close_room(
        jason: wire_Jason,
        room_to_delete: wire_RoomHandle,
    ) -> support::WireSyncReturn {
        wire_jason_close_room_impl(jason, room_to_delete)
    }

    #[no_mangle]
    pub extern "C" fn wire_jason_dispose(
        jason: wire_Jason,
    ) -> support::WireSyncReturn {
        wire_jason_dispose_impl(jason)
    }

    #[no_mangle]
    pub extern "C" fn wire_local_media_track_from_ptr(
        ptr: usize,
    ) -> support::WireSyncReturn {
        wire_local_media_track_from_ptr_impl(ptr)
    }

    #[no_mangle]
    pub extern "C" fn wire_vec_local_tracks_from_ptr(
        ptr: usize,
    ) -> support::WireSyncReturn {
        wire_vec_local_tracks_from_ptr_impl(ptr)
    }

    #[no_mangle]
    pub extern "C" fn wire_local_media_track_get_track(
        track: wire_LocalMediaTrack,
    ) -> support::WireSyncReturn {
        wire_local_media_track_get_track_impl(track)
    }

    #[no_mangle]
    pub extern "C" fn wire_local_media_track_kind(
        track: wire_LocalMediaTrack,
    ) -> support::WireSyncReturn {
        wire_local_media_track_kind_impl(track)
    }

    #[no_mangle]
    pub extern "C" fn wire_local_media_track_on_ended(
        track: wire_LocalMediaTrack,
        f: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_local_media_track_on_ended_impl(track, f)
    }

    #[no_mangle]
    pub extern "C" fn wire_local_media_track_state(
        track: wire_LocalMediaTrack,
    ) -> support::WireSyncReturn {
        wire_local_media_track_state_impl(track)
    }

    #[no_mangle]
    pub extern "C" fn wire_local_media_track_media_source_kind(
        track: wire_LocalMediaTrack,
    ) -> support::WireSyncReturn {
        wire_local_media_track_media_source_kind_impl(track)
    }

    #[no_mangle]
    pub extern "C" fn wire_local_media_track_free(
        track: wire_LocalMediaTrack,
    ) -> support::WireSyncReturn {
        wire_local_media_track_free_impl(track)
    }

    #[no_mangle]
    pub extern "C" fn wire_vec_media_device_details_from_ptr(
        ptr: usize,
    ) -> support::WireSyncReturn {
        wire_vec_media_device_details_from_ptr_impl(ptr)
    }

    #[no_mangle]
    pub extern "C" fn wire_vec_media_display_details_from_ptr(
        ptr: usize,
    ) -> support::WireSyncReturn {
        wire_vec_media_display_details_from_ptr_impl(ptr)
    }

    #[no_mangle]
    pub extern "C" fn wire_media_manager_handle_init_local_tracks(
        manager: wire_MediaManagerHandle,
        caps: *mut wire_ApiMediaStreamSettings,
    ) -> support::WireSyncReturn {
        wire_media_manager_handle_init_local_tracks_impl(manager, caps)
    }

    #[no_mangle]
    pub extern "C" fn wire_media_manager_handle_enumerate_devices(
        manager: wire_MediaManagerHandle,
    ) -> support::WireSyncReturn {
        wire_media_manager_handle_enumerate_devices_impl(manager)
    }

    #[no_mangle]
    pub extern "C" fn wire_media_manager_handle_enumerate_displays(
        manager: wire_MediaManagerHandle,
    ) -> support::WireSyncReturn {
        wire_media_manager_handle_enumerate_displays_impl(manager)
    }

    #[no_mangle]
    pub extern "C" fn wire_media_manager_handle_set_output_audio_id(
        manager: wire_MediaManagerHandle,
        device_id: *mut wire_uint_8_list,
    ) -> support::WireSyncReturn {
        wire_media_manager_handle_set_output_audio_id_impl(manager, device_id)
    }

    #[no_mangle]
    pub extern "C" fn wire_media_manager_handle_set_microphone_volume(
        manager: wire_MediaManagerHandle,
        level: i64,
    ) -> support::WireSyncReturn {
        wire_media_manager_handle_set_microphone_volume_impl(manager, level)
    }

    #[no_mangle]
    pub extern "C" fn wire_media_manager_handle_microphone_volume_is_available(
        manager: wire_MediaManagerHandle,
    ) -> support::WireSyncReturn {
        wire_media_manager_handle_microphone_volume_is_available_impl(manager)
    }

    #[no_mangle]
    pub extern "C" fn wire_media_manager_handle_microphone_volume(
        manager: wire_MediaManagerHandle,
    ) -> support::WireSyncReturn {
        wire_media_manager_handle_microphone_volume_impl(manager)
    }

    #[no_mangle]
    pub extern "C" fn wire_media_manager_handle_on_device_change(
        manager: wire_MediaManagerHandle,
        cb: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_media_manager_handle_on_device_change_impl(manager, cb)
    }

    #[no_mangle]
    pub extern "C" fn wire_reconnect_handle_from_ptr(
        ptr: usize,
    ) -> support::WireSyncReturn {
        wire_reconnect_handle_from_ptr_impl(ptr)
    }

    #[no_mangle]
    pub extern "C" fn wire_reconnect_handle_reconnect_with_delay(
        reconnect_handle: wire_ReconnectHandle,
        delay_ms: u32,
    ) -> support::WireSyncReturn {
        wire_reconnect_handle_reconnect_with_delay_impl(
            reconnect_handle,
            delay_ms,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_reconnect_handle_reconnect_with_backoff(
        reconnect_handle: wire_ReconnectHandle,
        starting_delay: u32,
        multiplier: f64,
        max_delay: u32,
        max_elapsed_time_ms: *mut u32,
    ) -> support::WireSyncReturn {
        wire_reconnect_handle_reconnect_with_backoff_impl(
            reconnect_handle,
            starting_delay,
            multiplier,
            max_delay,
            max_elapsed_time_ms,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_remote_media_track_from_ptr(
        ptr: usize,
    ) -> support::WireSyncReturn {
        wire_remote_media_track_from_ptr_impl(ptr)
    }

    #[no_mangle]
    pub extern "C" fn wire_remote_media_track_get_track(
        track: wire_RemoteMediaTrack,
    ) -> support::WireSyncReturn {
        wire_remote_media_track_get_track_impl(track)
    }

    #[no_mangle]
    pub extern "C" fn wire_remote_media_track_on_muted(
        track: wire_RemoteMediaTrack,
        f: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_remote_media_track_on_muted_impl(track, f)
    }

    #[no_mangle]
    pub extern "C" fn wire_remote_media_track_on_unmuted(
        track: wire_RemoteMediaTrack,
        f: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_remote_media_track_on_unmuted_impl(track, f)
    }

    #[no_mangle]
    pub extern "C" fn wire_remote_media_track_on_stopped(
        track: wire_RemoteMediaTrack,
        f: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_remote_media_track_on_stopped_impl(track, f)
    }

    #[no_mangle]
    pub extern "C" fn wire_remote_media_track_on_media_direction_changed(
        track: wire_RemoteMediaTrack,
        f: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_remote_media_track_on_media_direction_changed_impl(track, f)
    }

    #[no_mangle]
    pub extern "C" fn wire_remote_media_track_muted(
        track: wire_RemoteMediaTrack,
    ) -> support::WireSyncReturn {
        wire_remote_media_track_muted_impl(track)
    }

    #[no_mangle]
    pub extern "C" fn wire_remote_media_track_kind(
        track: wire_RemoteMediaTrack,
    ) -> support::WireSyncReturn {
        wire_remote_media_track_kind_impl(track)
    }

    #[no_mangle]
    pub extern "C" fn wire_remote_media_track_media_source_kind(
        track: wire_RemoteMediaTrack,
    ) -> support::WireSyncReturn {
        wire_remote_media_track_media_source_kind_impl(track)
    }

    #[no_mangle]
    pub extern "C" fn wire_remote_media_track_media_direction(
        track: wire_RemoteMediaTrack,
    ) -> support::WireSyncReturn {
        wire_remote_media_track_media_direction_impl(track)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_close_reason_from_ptr(
        ptr: usize,
    ) -> support::WireSyncReturn {
        wire_room_close_reason_from_ptr_impl(ptr)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_join(
        room_handle: wire_RoomHandle,
        token: *mut wire_uint_8_list,
    ) -> support::WireSyncReturn {
        wire_room_handle_join_impl(room_handle, token)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_set_local_media_settings(
        room_handle: wire_RoomHandle,
        settings: *mut wire_ApiMediaStreamSettings,
        stop_first: bool,
        rollback_on_fail: bool,
    ) -> support::WireSyncReturn {
        wire_room_handle_set_local_media_settings_impl(
            room_handle,
            settings,
            stop_first,
            rollback_on_fail,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_mute_audio(
        room_handle: wire_RoomHandle,
    ) -> support::WireSyncReturn {
        wire_room_handle_mute_audio_impl(room_handle)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_unmute_audio(
        room_handle: wire_RoomHandle,
    ) -> support::WireSyncReturn {
        wire_room_handle_unmute_audio_impl(room_handle)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_enable_audio(
        room_handle: wire_RoomHandle,
    ) -> support::WireSyncReturn {
        wire_room_handle_enable_audio_impl(room_handle)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_disable_audio(
        room_handle: wire_RoomHandle,
    ) -> support::WireSyncReturn {
        wire_room_handle_disable_audio_impl(room_handle)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_mute_video(
        room_handle: wire_RoomHandle,
        source_kind: *mut i32,
    ) -> support::WireSyncReturn {
        wire_room_handle_mute_video_impl(room_handle, source_kind)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_unmute_video(
        room_handle: wire_RoomHandle,
        source_kind: *mut i32,
    ) -> support::WireSyncReturn {
        wire_room_handle_unmute_video_impl(room_handle, source_kind)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_enable_video(
        room_handle: wire_RoomHandle,
        source_kind: *mut i32,
    ) -> support::WireSyncReturn {
        wire_room_handle_enable_video_impl(room_handle, source_kind)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_disable_video(
        room_handle: wire_RoomHandle,
        source_kind: *mut i32,
    ) -> support::WireSyncReturn {
        wire_room_handle_disable_video_impl(room_handle, source_kind)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_enable_remote_audio(
        room_handle: wire_RoomHandle,
    ) -> support::WireSyncReturn {
        wire_room_handle_enable_remote_audio_impl(room_handle)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_disable_remote_audio(
        room_handle: wire_RoomHandle,
    ) -> support::WireSyncReturn {
        wire_room_handle_disable_remote_audio_impl(room_handle)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_enable_remote_video(
        room_handle: wire_RoomHandle,
        source_kind: *mut i32,
    ) -> support::WireSyncReturn {
        wire_room_handle_enable_remote_video_impl(room_handle, source_kind)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_disable_remote_video(
        room_handle: wire_RoomHandle,
        source_kind: *mut i32,
    ) -> support::WireSyncReturn {
        wire_room_handle_disable_remote_video_impl(room_handle, source_kind)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_on_new_connection(
        room_handle: wire_RoomHandle,
        cb: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_room_handle_on_new_connection_impl(room_handle, cb)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_on_close(
        room_handle: wire_RoomHandle,
        cb: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_room_handle_on_close_impl(room_handle, cb)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_on_local_track(
        room_handle: wire_RoomHandle,
        cb: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_room_handle_on_local_track_impl(room_handle, cb)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_on_connection_loss(
        room_handle: wire_RoomHandle,
        cb: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_room_handle_on_connection_loss_impl(room_handle, cb)
    }

    #[no_mangle]
    pub extern "C" fn wire_room_handle_on_failed_local_media(
        room_handle: wire_RoomHandle,
        cb: wire_DartOpaque,
    ) -> support::WireSyncReturn {
        wire_room_handle_on_failed_local_media_impl(room_handle, cb)
    }

    #[no_mangle]
    pub extern "C" fn wire_log_dart_exception(
        message: *mut wire_uint_8_list,
        stack_trace: *mut wire_uint_8_list,
    ) -> support::WireSyncReturn {
        wire_log_dart_exception_impl(message, stack_trace)
    }

    // Section: allocate functions

    #[no_mangle]
    pub extern "C" fn new_ConnectionHandle() -> wire_ConnectionHandle {
        wire_ConnectionHandle::new_with_null_ptr()
    }

    #[no_mangle]
    pub extern "C" fn new_DartOpaque() -> wire_DartOpaque {
        wire_DartOpaque::new_with_null_ptr()
    }

    #[no_mangle]
    pub extern "C" fn new_Jason() -> wire_Jason {
        wire_Jason::new_with_null_ptr()
    }

    #[no_mangle]
    pub extern "C" fn new_LocalMediaTrack() -> wire_LocalMediaTrack {
        wire_LocalMediaTrack::new_with_null_ptr()
    }

    #[no_mangle]
    pub extern "C" fn new_MediaManagerHandle() -> wire_MediaManagerHandle {
        wire_MediaManagerHandle::new_with_null_ptr()
    }

    #[no_mangle]
    pub extern "C" fn new_ReconnectHandle() -> wire_ReconnectHandle {
        wire_ReconnectHandle::new_with_null_ptr()
    }

    #[no_mangle]
    pub extern "C" fn new_RemoteMediaTrack() -> wire_RemoteMediaTrack {
        wire_RemoteMediaTrack::new_with_null_ptr()
    }

    #[no_mangle]
    pub extern "C" fn new_RoomHandle() -> wire_RoomHandle {
        wire_RoomHandle::new_with_null_ptr()
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_api_audio_constraints_0(
    ) -> *mut wire_ApiAudioConstraints {
        support::new_leak_box_ptr(wire_ApiAudioConstraints::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_api_constrain_facing_mode_0(
    ) -> *mut wire_ApiConstrainFacingMode {
        support::new_leak_box_ptr(
            wire_ApiConstrainFacingMode::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_api_device_video_track_constraints_0(
    ) -> *mut wire_ApiDeviceVideoTrackConstraints {
        support::new_leak_box_ptr(
            wire_ApiDeviceVideoTrackConstraints::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_api_display_video_track_constraints_0(
    ) -> *mut wire_ApiDisplayVideoTrackConstraints {
        support::new_leak_box_ptr(
            wire_ApiDisplayVideoTrackConstraints::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_api_media_stream_settings_0(
    ) -> *mut wire_ApiMediaStreamSettings {
        support::new_leak_box_ptr(
            wire_ApiMediaStreamSettings::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_constrain_boolean_0(
    ) -> *mut wire_ConstrainBoolean {
        support::new_leak_box_ptr(wire_ConstrainBoolean::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_constrain_u_32_0(
    ) -> *mut wire_ConstrainU32 {
        support::new_leak_box_ptr(wire_ConstrainU32::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_media_source_kind_0(
        value: i32,
    ) -> *mut i32 {
        support::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_u32_0(value: u32) -> *mut u32 {
        support::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn new_uint_8_list_0(len: i32) -> *mut wire_uint_8_list {
        let ans = wire_uint_8_list {
            ptr: support::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        support::new_leak_box_ptr(ans)
    }

    // Section: related functions

    #[no_mangle]
    pub extern "C" fn drop_opaque_ConnectionHandle(ptr: *const c_void) {
        unsafe {
            Arc::<ConnectionHandle>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn share_opaque_ConnectionHandle(
        ptr: *const c_void,
    ) -> *const c_void {
        unsafe {
            Arc::<ConnectionHandle>::increment_strong_count(ptr as _);
            ptr
        }
    }

    #[no_mangle]
    pub extern "C" fn drop_opaque_Jason(ptr: *const c_void) {
        unsafe {
            Arc::<Jason>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn share_opaque_Jason(ptr: *const c_void) -> *const c_void {
        unsafe {
            Arc::<Jason>::increment_strong_count(ptr as _);
            ptr
        }
    }

    #[no_mangle]
    pub extern "C" fn drop_opaque_LocalMediaTrack(ptr: *const c_void) {
        unsafe {
            Arc::<LocalMediaTrack>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn share_opaque_LocalMediaTrack(
        ptr: *const c_void,
    ) -> *const c_void {
        unsafe {
            Arc::<LocalMediaTrack>::increment_strong_count(ptr as _);
            ptr
        }
    }

    #[no_mangle]
    pub extern "C" fn drop_opaque_MediaManagerHandle(ptr: *const c_void) {
        unsafe {
            Arc::<MediaManagerHandle>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn share_opaque_MediaManagerHandle(
        ptr: *const c_void,
    ) -> *const c_void {
        unsafe {
            Arc::<MediaManagerHandle>::increment_strong_count(ptr as _);
            ptr
        }
    }

    #[no_mangle]
    pub extern "C" fn drop_opaque_ReconnectHandle(ptr: *const c_void) {
        unsafe {
            Arc::<ReconnectHandle>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn share_opaque_ReconnectHandle(
        ptr: *const c_void,
    ) -> *const c_void {
        unsafe {
            Arc::<ReconnectHandle>::increment_strong_count(ptr as _);
            ptr
        }
    }

    #[no_mangle]
    pub extern "C" fn drop_opaque_RemoteMediaTrack(ptr: *const c_void) {
        unsafe {
            Arc::<RemoteMediaTrack>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn share_opaque_RemoteMediaTrack(
        ptr: *const c_void,
    ) -> *const c_void {
        unsafe {
            Arc::<RemoteMediaTrack>::increment_strong_count(ptr as _);
            ptr
        }
    }

    #[no_mangle]
    pub extern "C" fn drop_opaque_RoomHandle(ptr: *const c_void) {
        unsafe {
            Arc::<RoomHandle>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn share_opaque_RoomHandle(
        ptr: *const c_void,
    ) -> *const c_void {
        unsafe {
            Arc::<RoomHandle>::increment_strong_count(ptr as _);
            ptr
        }
    }

    // Section: impl Wire2Api

    impl Wire2Api<RustOpaque<ConnectionHandle>> for wire_ConnectionHandle {
        fn wire2api(self) -> RustOpaque<ConnectionHandle> {
            unsafe { support::opaque_from_dart(self.ptr as _) }
        }
    }
    impl Wire2Api<DartOpaque> for wire_DartOpaque {
        fn wire2api(self) -> DartOpaque {
            unsafe { DartOpaque::new(self.handle as _, self.port) }
        }
    }
    impl Wire2Api<RustOpaque<Jason>> for wire_Jason {
        fn wire2api(self) -> RustOpaque<Jason> {
            unsafe { support::opaque_from_dart(self.ptr as _) }
        }
    }
    impl Wire2Api<RustOpaque<LocalMediaTrack>> for wire_LocalMediaTrack {
        fn wire2api(self) -> RustOpaque<LocalMediaTrack> {
            unsafe { support::opaque_from_dart(self.ptr as _) }
        }
    }
    impl Wire2Api<RustOpaque<MediaManagerHandle>> for wire_MediaManagerHandle {
        fn wire2api(self) -> RustOpaque<MediaManagerHandle> {
            unsafe { support::opaque_from_dart(self.ptr as _) }
        }
    }
    impl Wire2Api<RustOpaque<ReconnectHandle>> for wire_ReconnectHandle {
        fn wire2api(self) -> RustOpaque<ReconnectHandle> {
            unsafe { support::opaque_from_dart(self.ptr as _) }
        }
    }
    impl Wire2Api<RustOpaque<RemoteMediaTrack>> for wire_RemoteMediaTrack {
        fn wire2api(self) -> RustOpaque<RemoteMediaTrack> {
            unsafe { support::opaque_from_dart(self.ptr as _) }
        }
    }
    impl Wire2Api<RustOpaque<RoomHandle>> for wire_RoomHandle {
        fn wire2api(self) -> RustOpaque<RoomHandle> {
            unsafe { support::opaque_from_dart(self.ptr as _) }
        }
    }
    impl Wire2Api<String> for *mut wire_uint_8_list {
        fn wire2api(self) -> String {
            let vec: Vec<u8> = self.wire2api();
            String::from_utf8_lossy(&vec).into_owned()
        }
    }
    impl Wire2Api<ApiAudioConstraints> for wire_ApiAudioConstraints {
        fn wire2api(self) -> ApiAudioConstraints {
            ApiAudioConstraints {
                device_id: self.device_id.wire2api(),
                auto_gain_control: self.auto_gain_control.wire2api(),
            }
        }
    }
    impl Wire2Api<ApiConstrainFacingMode> for wire_ApiConstrainFacingMode {
        fn wire2api(self) -> ApiConstrainFacingMode {
            match self.tag {
                0 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Exact);
                    ApiConstrainFacingMode::Exact(ans.field0.wire2api())
                },
                1 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Ideal);
                    ApiConstrainFacingMode::Ideal(ans.field0.wire2api())
                },
                _ => unreachable!(),
            }
        }
    }
    impl Wire2Api<ApiDeviceVideoTrackConstraints>
        for wire_ApiDeviceVideoTrackConstraints
    {
        fn wire2api(self) -> ApiDeviceVideoTrackConstraints {
            ApiDeviceVideoTrackConstraints {
                device_id: self.device_id.wire2api(),
                facing_mode: self.facing_mode.wire2api(),
                height: self.height.wire2api(),
                width: self.width.wire2api(),
            }
        }
    }
    impl Wire2Api<ApiDisplayVideoTrackConstraints>
        for wire_ApiDisplayVideoTrackConstraints
    {
        fn wire2api(self) -> ApiDisplayVideoTrackConstraints {
            ApiDisplayVideoTrackConstraints {
                device_id: self.device_id.wire2api(),
                height: self.height.wire2api(),
                width: self.width.wire2api(),
                frame_rate: self.frame_rate.wire2api(),
            }
        }
    }
    impl Wire2Api<ApiMediaStreamSettings> for wire_ApiMediaStreamSettings {
        fn wire2api(self) -> ApiMediaStreamSettings {
            ApiMediaStreamSettings {
                audio: self.audio.wire2api(),
                device_video: self.device_video.wire2api(),
                display_video: self.display_video.wire2api(),
            }
        }
    }

    impl Wire2Api<ApiAudioConstraints> for *mut wire_ApiAudioConstraints {
        fn wire2api(self) -> ApiAudioConstraints {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<ApiAudioConstraints>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<ApiConstrainFacingMode> for *mut wire_ApiConstrainFacingMode {
        fn wire2api(self) -> ApiConstrainFacingMode {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<ApiConstrainFacingMode>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<ApiDeviceVideoTrackConstraints>
        for *mut wire_ApiDeviceVideoTrackConstraints
    {
        fn wire2api(self) -> ApiDeviceVideoTrackConstraints {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<ApiDeviceVideoTrackConstraints>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<ApiDisplayVideoTrackConstraints>
        for *mut wire_ApiDisplayVideoTrackConstraints
    {
        fn wire2api(self) -> ApiDisplayVideoTrackConstraints {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<ApiDisplayVideoTrackConstraints>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<ApiMediaStreamSettings> for *mut wire_ApiMediaStreamSettings {
        fn wire2api(self) -> ApiMediaStreamSettings {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<ApiMediaStreamSettings>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<ConstrainBoolean> for *mut wire_ConstrainBoolean {
        fn wire2api(self) -> ConstrainBoolean {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<ConstrainBoolean>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<ConstrainU32> for *mut wire_ConstrainU32 {
        fn wire2api(self) -> ConstrainU32 {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<ConstrainU32>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<MediaSourceKind> for *mut i32 {
        fn wire2api(self) -> MediaSourceKind {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<MediaSourceKind>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<u32> for *mut u32 {
        fn wire2api(self) -> u32 {
            unsafe { *support::box_from_leak_ptr(self) }
        }
    }
    impl Wire2Api<ConstrainBoolean> for wire_ConstrainBoolean {
        fn wire2api(self) -> ConstrainBoolean {
            match self.tag {
                0 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Exact);
                    ConstrainBoolean::Exact(ans.field0.wire2api())
                },
                1 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Ideal);
                    ConstrainBoolean::Ideal(ans.field0.wire2api())
                },
                _ => unreachable!(),
            }
        }
    }
    impl Wire2Api<ConstrainU32> for wire_ConstrainU32 {
        fn wire2api(self) -> ConstrainU32 {
            match self.tag {
                0 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Exact);
                    ConstrainU32::Exact(ans.field0.wire2api())
                },
                1 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Ideal);
                    ConstrainU32::Ideal(ans.field0.wire2api())
                },
                2 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Range);
                    ConstrainU32::Range(
                        ans.field0.wire2api(),
                        ans.field1.wire2api(),
                    )
                },
                _ => unreachable!(),
            }
        }
    }

    impl Wire2Api<Vec<u8>> for *mut wire_uint_8_list {
        fn wire2api(self) -> Vec<u8> {
            unsafe {
                let wrap = support::box_from_leak_ptr(self);
                support::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }

    // Section: wire structs

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ConnectionHandle {
        ptr: *const core::ffi::c_void,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_DartOpaque {
        port: i64,
        handle: usize,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Jason {
        ptr: *const core::ffi::c_void,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_LocalMediaTrack {
        ptr: *const core::ffi::c_void,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_MediaManagerHandle {
        ptr: *const core::ffi::c_void,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ReconnectHandle {
        ptr: *const core::ffi::c_void,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_RemoteMediaTrack {
        ptr: *const core::ffi::c_void,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_RoomHandle {
        ptr: *const core::ffi::c_void,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ApiAudioConstraints {
        device_id: *mut wire_uint_8_list,
        auto_gain_control: *mut wire_ConstrainBoolean,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ApiDeviceVideoTrackConstraints {
        device_id: *mut wire_uint_8_list,
        facing_mode: *mut wire_ApiConstrainFacingMode,
        height: *mut wire_ConstrainU32,
        width: *mut wire_ConstrainU32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ApiDisplayVideoTrackConstraints {
        device_id: *mut wire_uint_8_list,
        height: *mut wire_ConstrainU32,
        width: *mut wire_ConstrainU32,
        frame_rate: *mut wire_ConstrainU32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ApiMediaStreamSettings {
        audio: *mut wire_ApiAudioConstraints,
        device_video: *mut wire_ApiDeviceVideoTrackConstraints,
        display_video: *mut wire_ApiDisplayVideoTrackConstraints,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_uint_8_list {
        ptr: *mut u8,
        len: i32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ApiConstrainFacingMode {
        tag: i32,
        kind: *mut ApiConstrainFacingModeKind,
    }

    #[repr(C)]
    pub union ApiConstrainFacingModeKind {
        Exact: *mut wire_ApiConstrainFacingMode_Exact,
        Ideal: *mut wire_ApiConstrainFacingMode_Ideal,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ApiConstrainFacingMode_Exact {
        field0: i32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ApiConstrainFacingMode_Ideal {
        field0: i32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ConstrainBoolean {
        tag: i32,
        kind: *mut ConstrainBooleanKind,
    }

    #[repr(C)]
    pub union ConstrainBooleanKind {
        Exact: *mut wire_ConstrainBoolean_Exact,
        Ideal: *mut wire_ConstrainBoolean_Ideal,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ConstrainBoolean_Exact {
        field0: bool,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ConstrainBoolean_Ideal {
        field0: bool,
    }
    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ConstrainU32 {
        tag: i32,
        kind: *mut ConstrainU32Kind,
    }

    #[repr(C)]
    pub union ConstrainU32Kind {
        Exact: *mut wire_ConstrainU32_Exact,
        Ideal: *mut wire_ConstrainU32_Ideal,
        Range: *mut wire_ConstrainU32_Range,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ConstrainU32_Exact {
        field0: u32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ConstrainU32_Ideal {
        field0: u32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ConstrainU32_Range {
        field0: u32,
        field1: u32,
    }

    // Section: impl NewWithNullPtr

    pub trait NewWithNullPtr {
        fn new_with_null_ptr() -> Self;
    }

    impl<T> NewWithNullPtr for *mut T {
        fn new_with_null_ptr() -> Self {
            std::ptr::null_mut()
        }
    }

    impl NewWithNullPtr for wire_ConnectionHandle {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: core::ptr::null(),
            }
        }
    }
    impl NewWithNullPtr for wire_DartOpaque {
        fn new_with_null_ptr() -> Self {
            Self { port: 0, handle: 0 }
        }
    }
    impl NewWithNullPtr for wire_Jason {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: core::ptr::null(),
            }
        }
    }
    impl NewWithNullPtr for wire_LocalMediaTrack {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: core::ptr::null(),
            }
        }
    }
    impl NewWithNullPtr for wire_MediaManagerHandle {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: core::ptr::null(),
            }
        }
    }
    impl NewWithNullPtr for wire_ReconnectHandle {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: core::ptr::null(),
            }
        }
    }
    impl NewWithNullPtr for wire_RemoteMediaTrack {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: core::ptr::null(),
            }
        }
    }
    impl NewWithNullPtr for wire_RoomHandle {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: core::ptr::null(),
            }
        }
    }

    impl NewWithNullPtr for wire_ApiAudioConstraints {
        fn new_with_null_ptr() -> Self {
            Self {
                device_id: core::ptr::null_mut(),
                auto_gain_control: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_ApiAudioConstraints {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl Default for wire_ApiConstrainFacingMode {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_ApiConstrainFacingMode {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: core::ptr::null_mut(),
            }
        }
    }

    #[no_mangle]
    pub extern "C" fn inflate_ApiConstrainFacingMode_Exact(
    ) -> *mut ApiConstrainFacingModeKind {
        support::new_leak_box_ptr(ApiConstrainFacingModeKind {
            Exact: support::new_leak_box_ptr(
                wire_ApiConstrainFacingMode_Exact {
                    field0: Default::default(),
                },
            ),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_ApiConstrainFacingMode_Ideal(
    ) -> *mut ApiConstrainFacingModeKind {
        support::new_leak_box_ptr(ApiConstrainFacingModeKind {
            Ideal: support::new_leak_box_ptr(
                wire_ApiConstrainFacingMode_Ideal {
                    field0: Default::default(),
                },
            ),
        })
    }

    impl NewWithNullPtr for wire_ApiDeviceVideoTrackConstraints {
        fn new_with_null_ptr() -> Self {
            Self {
                device_id: core::ptr::null_mut(),
                facing_mode: core::ptr::null_mut(),
                height: core::ptr::null_mut(),
                width: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_ApiDeviceVideoTrackConstraints {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_ApiDisplayVideoTrackConstraints {
        fn new_with_null_ptr() -> Self {
            Self {
                device_id: core::ptr::null_mut(),
                height: core::ptr::null_mut(),
                width: core::ptr::null_mut(),
                frame_rate: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_ApiDisplayVideoTrackConstraints {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_ApiMediaStreamSettings {
        fn new_with_null_ptr() -> Self {
            Self {
                audio: core::ptr::null_mut(),
                device_video: core::ptr::null_mut(),
                display_video: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_ApiMediaStreamSettings {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl Default for wire_ConstrainBoolean {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_ConstrainBoolean {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: core::ptr::null_mut(),
            }
        }
    }

    #[no_mangle]
    pub extern "C" fn inflate_ConstrainBoolean_Exact(
    ) -> *mut ConstrainBooleanKind {
        support::new_leak_box_ptr(ConstrainBooleanKind {
            Exact: support::new_leak_box_ptr(wire_ConstrainBoolean_Exact {
                field0: Default::default(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_ConstrainBoolean_Ideal(
    ) -> *mut ConstrainBooleanKind {
        support::new_leak_box_ptr(ConstrainBooleanKind {
            Ideal: support::new_leak_box_ptr(wire_ConstrainBoolean_Ideal {
                field0: Default::default(),
            }),
        })
    }

    impl Default for wire_ConstrainU32 {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_ConstrainU32 {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: core::ptr::null_mut(),
            }
        }
    }

    #[no_mangle]
    pub extern "C" fn inflate_ConstrainU32_Exact() -> *mut ConstrainU32Kind {
        support::new_leak_box_ptr(ConstrainU32Kind {
            Exact: support::new_leak_box_ptr(wire_ConstrainU32_Exact {
                field0: Default::default(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_ConstrainU32_Ideal() -> *mut ConstrainU32Kind {
        support::new_leak_box_ptr(ConstrainU32Kind {
            Ideal: support::new_leak_box_ptr(wire_ConstrainU32_Ideal {
                field0: Default::default(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_ConstrainU32_Range() -> *mut ConstrainU32Kind {
        support::new_leak_box_ptr(ConstrainU32Kind {
            Range: support::new_leak_box_ptr(wire_ConstrainU32_Range {
                field0: Default::default(),
                field1: Default::default(),
            }),
        })
    }

    // Section: sync execution mode utility

    #[no_mangle]
    pub extern "C" fn free_WireSyncReturn(ptr: support::WireSyncReturn) {
        unsafe {
            let _ = support::box_from_leak_ptr(ptr);
        };
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
